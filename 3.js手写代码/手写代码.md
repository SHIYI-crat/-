# 手写代码

## 一、js基础
### 1、手写Object.create


~~~js
function create(obj){
    function F(){}
    F.prototype = obj
    return new F()
}
~~~



### 2、

~~~js

~~~



 ###

~~~js

~~~





## 二、数据处理

### 1、实现日期格式化函数

~~~js
const dateFormat = (dateInput, format) => {
    var day = dateInput.getDate()
    var month = dateInput.getMonth() + 1    //返回一个处于0到11之间的整数
    var year = dateInput.getFullYear()
    format = format.replace(/yyyy/, year)
    format = format.replace(/MM/, month)
    format = format.replace(/dd/, day)
    return format
}
console.log(dateFormat(new Date('2023-02-01'), 'yyyy/MM/dd'))
~~~

### 2、交换a,b的值，不使用临时变量

~~~js
a = a + b;
b = a - b;
a = a - b;
------------------------------
[a, b] = [b, a];
~~~

### 3、数组的乱序输出

~~~js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (let i = 0; i < arr.length; i++) {
    const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;
    [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];
}
console.log(arr)
~~~

### 4、数组元素求和

~~~js
// arr = [1,2,3,4,5]
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce((total, i) => total += i, 0);
---------------------------------------------------
// arr = [1,2,[[3,4],5]]
let arr = [1, 2, [[3, 4], 5]]
let sum = arr.toString().split(',').reduce((total, i) => total += Number(i), 0);
console.log(sum)
~~~

### 5、数组扁平化

数组扁平化是指将多维数组变成一维数组

~~~js
//toString和split
const arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.toString().split(',');
}
---------------------------------------------
//ES6中的flat
const arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.flat(Infinity);
}
~~~

### 6、实现数组去重

~~~js
//ES5方法，循环+splice
const array = [1, 2, 3, 1, 2, 4, 1];
function uniqueArray(array) {
    for (let i = 0; i < array.length; i++) {
        for (let j = i + 1; j < array.length; j++) {
            if (array[i] == array[j]) {
                array.splice(j, 1);
                j--;
            }
        }
    }
    return array;
}
console.log(uniqueArray(array));
-----------------------------------
//ES6方法，使用集合
const arr = [1, 2, 3, 1, 2, 4, 1];
console.log(Array.from(new Set(arr)));
~~~

###

~~~js

~~~

###

~~~js

~~~

###

~~~js

~~~






## 三、场景应用

### 1、循环打印红黄绿灯

~~~js
//红黄绿:使用异步编程方案;循环打印:一轮打印完了以后递归重复这一过程使用异步编程方案
const taskRunner = (light, timeout) => {
    return new Promise((resolve) => {
        setTimeout(() => resolve(console.log(light)), timeout);
    })
}
const task = async () => {
    await taskRunner('红', 1000)
    await taskRunner('绿', 3000)
    await taskRunner('黄', 2000)
    task()
}

task()
~~~

### 2、每隔一秒打印1,2,3,4

~~~js
//使用定时器
for (let i = 0; i < 4; i++) {
    setTimeout(function () {
        console.log(i + 1)
    }, i * 1000)
}
~~~

### 3、小孩报数问题

有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3数到3的小孩儿退出这个圈，然后下一个小孩重新报数1、2、3，问最后剩下的那个小孩儿的编号是多少?

~~~js
function childNum(num, count) {
    // 用数组记录
    let allplayer = [];
    for (let i = 0; i < num; i++) {
        allplayer[i] = i + 1;
    }

    let exitCount = 0;  //离开人数
    let counter = 0;    //记录报数
    let curIndex = 0;   //当前下标

    while (exitCount < num - 1) {
        if (allplayer[curIndex] !== 0) counter++;
        if (counter == count) {
            allplayer[curIndex] = 0;
            counter = 0;
            exitCount++;
        }
        curIndex++;
        if (curIndex == num) curIndex = 0;
    }
    for (let i = 0; i < num; i++) {
        if (allplayer[i] !== 0) {
            return allplayer[i]
        }
    }
}
console.log(childNum(30, 3))
~~~

### 4、Promise实现图片的异步加载

~~~js
let imageAsync = (url) => {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.src = url;
        img.onload = (image) => {
            console.log('图片请求成功')
            resolve(image)
        }
        img.onerror = (err) => {
            console.log('图片请求失败')
            reject(err)
        }
    })
}
imageAsync("url").then(() => {
    console.log("加载成功")
}).catch((error) => {
    console.log("加载失败")
})
~~~

###  5、实现发布-订阅者模式

~~~js
class EventCenter {
    // 1.定义事件容器
    constructor() {
        this.handlers = {}
    }
    // 2.添加事件方法（事件名，事件方法）
    addEventListener(type, handler) {
        // 创建新数组容器
        if (!this.handlers[type]) {
            this.handlers[type] = []
        }
        // 存入事件
        this.handlers[type].push(handler)
    }
    // 3.触发事件（事件名，事件参数）
    dispatchEvent(type, params) {
        // 没有注册该事件则抛出错误
        if (!this.handlers[type]) {
            return new Error('该事件未注册')
        }
        // 触发事件
        this.handlers[type].forEach(handler => {
            handler(...params)
        });
    }
    // 4.事件移除      （事件名，事件方法）
    removeEventListener(type, handler) {
        if (!this.handlers[type]) {
            return new Error('事件无效')
        }
        if (!handler) {
            // 移除事件
            delete this.handlers[type]
        } else {
            const index = this.handlers[type].findIndex(el => el === handler)
            if (index === -1) {
                return new Error('无法绑定该事件')
            }
        }
        // 移除事件
        this.handlers[type].splice(index, 1)
        if (this.handlers[type].length === 0) {
            delete this.handlers[type]
        }
    }
}
~~~

### 6、查找文章中出现频率最高的单词

~~~js
function counts(article) {
    article = article.trim().toUpperCase();
    var array = article.match(/[A-z]+/g);
    article = " " + array.join("  ") + " ";
    var max = 0, word, num = 0, maxword = "";
    for (var i = 0; i < array.length; i++) {
        word = new RegExp(" " + array[i] + " ", 'g');
        num = article.match(word).length;
        if (num > max) {
            max = num;
            maxword = array[i];
        }
    }
    console.log(maxword + " " + max);
}
counts("I fall in love with I at the first sight!");
~~~

### 7、封装异步的fetch，使用async,await方式使用

~~~js
(async () => {
    class HttpRequestUtil {
        async get(url) {
            const res = await fetch(url)
            const data = await res.json()
            return data
        }
        async post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
        async put(url, data) {
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
        async delete(url, data) {
            const res = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
    }
    const httpRequestUtil = new HttpRequestUtil()
    const res = await httpRequestUtil.get('https://www.baidu.com/')
    console.log(res)
})();
~~~

### 8、实现prototype继承

原型链继承就是让新实例的原型等于父类的实例

~~~js
function FatherFunction(flag1) {
    this.flag1 = flag1;
}
function SonFunction(flag2) {
    this.flag2 = flag2;
}
var fatherInstance = new FatherFunction(true);
SonFunction.prototype = fatherInstance;
var sonInstance = new SonFunction(false);
console.log(sonInstance.flag1); //true
console.log(sonInstance.flag2); //false
~~~

### 9、实现双向数据绑定

~~~js
<body>
    <input type="text" id="input">
    <span id="span"></span>

    <script>
        let obj = {}
        let input = document.getElementById('input')
        let sapn = document.getElementById('span')
        Object.defineProperty(obj, 'text', {
            get() {
                console.log('获取数据了')
            },
            set(newVal) {
                console.log('获取数据了')
                input.value = newVal
                span.innerHTML = newVal
            }
        })
        input.addEventListener('keyup', function (e) {
            obj.text = e.target.value
        })
    </script>
</body>
~~~

### 10.实现简单路由

~~~js
<body>
    <ul>
        <li><a onclick="location.href='#/'">首页</a></li>
        <li><a href="#/product">产品</a></li>
        <li><a onclick="location.href='#/server'">服务</a></li>
    </ul>
    <div id="result"></div>

    <script type="text/javascript">
        function Router() {
            this.routers = {};
            this.curUrl = '';

            this.route = function (path, callback) {
                this.routers[path] = callback || function () { };
            };

            this.refresh = function () {
                console.log(location.hash);
                this.curUrl = location.hash.slice(1) || '/';
                this.routers[this.curUrl]();
            }
            this.init = function () {
                window.addEventListener('load', this.refresh.bind(this), false);
                window.addEventListener('hashchange', this.refresh.bind(this), false);
            }
        }

        var R = new Router();
        R.init();
        var res = document.getElementById('result');

        R.route('/', function () {
            res.style.background = 'blue';
            res.innerHTML = '这是首页';
        });
        R.route('/product', function () {
            res.style.background = 'orange';
            res.innerHTML = '这是产品页';
        });
        R.route('/server', function () {
            res.style.background = 'black';
            res.innerHTML = '这是服务页';
        });
    </script>
</body>
~~~


### 11、实现斐波拉契数列

~~~js
function fn(n) {
    if (n == 1 || n == 2) {
        return 1
    } else {
        return fn(n - 2) + fn(n - 1)
    }
}
--------------------------------------
function fn(n) {
    var num1 = 1, num2 = 1, sum;

    for (var i = 3; i <= n; i++) {
        sum = num1 + num2;   //用sum累加前两个数之和
        num1 = num2;
        num2 = sum;
    }

    if (n == 1 || n == 2) {
        return 1
    } else {
        return sum
    }
}
~~~

### 12、字符串中无重复字符的最长子串

滑动窗口装没有重复的字符，用map维护字符的索引

~~~js
var lengthOfLongestSubstring = function (s) {
    let map = new Map()
    let i = -1
    let res = 0
    let len = s.length
    for (let j = 0; j < len; j++) {
        if (map.has(s[j])) {
            i = Math.max(i, map.get(s[j]))
        }
        res = Math.max(res, j - i)
        map.set(s[j], j)
    }
    return res
}
~~~

### 13、使用setTimeout实现setInterval

setInterval不是每隔一段时间立即执行，而是每隔一段时间将事件加入事件队列中，只有当前执行栈为空时，才能从事件队列中取出事件执行，积累多个事件的话就不能实现间隔执行的效果

~~~js
function mySetInterval(fn, timeout) {
    var timer = { flag: true }
    // 设置递归函数，模拟定时器执行
    function interval() {
        if (time.flag) {
            fn()
            setTimeout(interval, timeout)
        }
    }
}
// 启动定时器
setTimeout(interval, timeout)
// 返回控制器
return timer
~~~

### 14、实现jsonp

JSONP(JSON with Padding)是[JSON](https://baike.baidu.com/item/JSON?fromModule=lemma_inlink)的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题，利用的就是script的src标签没有跨域限制来实现的

~~~js
function addScript(src) {
    const script = document.createElement('script')
    script.src = src
    script.type = "text/javascript"
    document.body.appendChild(script)
}
addScript("http://xxx.xxx.com/xxx.js?callback=handleRes")
function handleRes(res) {
    console.log(res)
}
handleRes({ a: 1, b: 2 })
~~~

### 15、判断对象之间是否存在循环引用

循环引用是指对象中的属性指向对象本身，如果属性内部的深层属性指向对象本身，也属于循环引用

~~~js
const isCycleObject = (obj, parent) => {
    const parentArr = parent || [obj];
    for (let i in obj) {
        if (typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) => {
                if (pObj === obj[i]) {
                    flag = true;
                }
            })
            if (flag) return true;
            flag = isCycleObject(obj[i], [...parentArr, obj[i]]);
            if (flag) return true;
        }
    }
    return false;
}

let a = {}
a.b = {}
a.b.c = a
console.log(isCycleObject(a))
~~~





