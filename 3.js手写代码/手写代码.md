# 手写代码

## 一、js基础
### 1、手写Object.create


~~~js
function create(obj){
    function F(){}
    F.prototype = obj
    return new F()
}
~~~



### 2、

~~~js

~~~



 ###

~~~js

~~~





## 二、数据处理

### 1、实现日期格式化函数

~~~js
const dateFormat = (dateInput, format) => {
    var day = dateInput.getDate()
    var month = dateInput.getMonth() + 1    //返回一个处于0到11之间的整数
    var year = dateInput.getFullYear()
    format = format.replace(/yyyy/, year)
    format = format.replace(/MM/, month)
    format = format.replace(/dd/, day)
    return format
}
console.log(dateFormat(new Date('2023-02-01'), 'yyyy/MM/dd'))
~~~

### 2、交换a,b的值，不使用临时变量

~~~js
a = a + b;
b = a - b;
a = a - b;
------------------------------
[a, b] = [b, a];
~~~

### 3、数组的乱序输出

~~~js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (let i = 0; i < arr.length; i++) {
    const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;
    [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];
}
console.log(arr)
~~~

### 4、数组元素求和

~~~js
// arr = [1,2,3,4,5]
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce((total, i) => total += i, 0);
---------------------------------------------------
// arr = [1,2,[[3,4],5]]
let arr = [1, 2, [[3, 4], 5]]
let sum = arr.toString().split(',').reduce((total, i) => total += Number(i), 0);
console.log(sum)
~~~

### 5、数组扁平化

数组扁平化是指将多维数组变成一维数组

~~~js
//toString和split
const arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.toString().split(',');
}
---------------------------------------------
//ES6中的flat
const arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.flat(Infinity);
}
~~~

### 6、实现数组去重

~~~js
//ES5方法，循环+splice
const array = [1, 2, 3, 1, 2, 4, 1];
function uniqueArray(array) {
    for (let i = 0; i < array.length; i++) {
        for (let j = i + 1; j < array.length; j++) {
            if (array[i] == array[j]) {
                array.splice(j, 1);
                j--;
            }
        }
    }
    return array;
}
console.log(uniqueArray(array));
-----------------------------------
//ES6方法，使用集合
const arr = [1, 2, 3, 1, 2, 4, 1];
console.log(Array.from(new Set(arr)));
~~~

### 7、实现数组的flat方法

~~~js
function _flat(arr, depth) {
    if (!Array.isArray(arr) || depth <= 0) {
        return arr;
    }
    return arr.reducr((prev, cur) => {
        if (Array.isArray(cur)) {
            return pre.concat(_flat(cur, depth - 1));
        } elseP
        return pre.concat(cur);
    }, [])
}
~~~

### 8、实现数组的push方法

~~~js
const arr = [];
Array.prototype.push = function () {
    for (let i = 0; i < arguments.length; i++) {
        this[this.length] = arguments[i];
    }
    return this.length
}
~~~

### 9、实现数组的filter方法

~~~js
Array.prototype._filter = function (fn) {
    if (typeof fn !== "function") {
        throw Error('参数必须是一个函数');
    }
    const res = [];
    for (let i = 0, len = this.length; i < len; i++) {
        fn(this[i] && res.push(this[i]));
    }
    return res
}
~~~

### 10、实现数组的map方法

~~~js
Array.prototype._map = function (fn) {
    if (typeof fn !== "function") {
        throw Error('参数必须是一个函数');
    }
    const res = [];
    for (let i = 0, len = this.length; i < len; i++) {
        res.push(fn(this[i]));
    }
    return res
}
~~~

### 11、实现字符串的repeat方法

~~~js
//参数：字符串，重复次数
function repeat(s, n) {
    return (new Array(n + 1)).join(s);
}
~~~

### 12、实现字符串翻转

~~~js
//数组是reverse，实现字符串_reverse
String.prototype._reverse = function (a) {
    return a.split("").reverse().join("");
}
~~~

### 13、数字每千分位用逗号隔开

~~~js
//考虑小数的情况，遍历每三位添加“,”
const numFormat = param => {
    const num = param + '';
    const numGroup = num.includes('.') ? num.split('.') : [num];
    const intFn = numStr =>
        numStr
            .split('')
            .reverse()
            .reduce((prev, next, index) => {
                return (index % 3 ? next : next + ',') + prev;
            });
    const intNum = intFn(numGroup[0]);
    const floatNum = numGroup[1] ? '.' + numGroup[1] : '';
    return intNum + floatNum;
};
-------------------------------------------
//忽略小数的情况，toLocaleString()
let num1 = 12345678912345;
let num2 = 987654.321056;

console.log(num1.toLocaleString()); // "12,345,678,912,345"
console.log(num2.toLocaleString()); // "987,654.321" （小数部分四舍五入了）
~~~

### 14、大数相加相乘

~~~js
//大数相加
function add(a, b) {
    let res = '';
    let temp = 0;
    // 字符串保存大数
    a = a.split('');
    b = b.split('');
    // 对应的位进行相加，结果可能大于10，会产生进位，所以要进行取余操作
    while (a.length || b.length || temp) {
        temp += ~~a.pop() + ~~b.pop();
        res = (temp % 10) + res;
        temp = temp > 9;
    }
    return res.replace(/^0+/, '');
}
-------------------------------------------
//大数相乘(要理解)
let multiply = function (num1, num2) {
    if (isNaN(num1) || isNaN(num2)) return '';
    if (num1 === '0' || num2 === '0') return '0';

    let result = [];
    
    for (let i = num1.length - 1; i >= 0; i--) {
        for (let j = num2.length - 1; j >= 0; j--) {
            let index1 = i + j;
            let index2 = i + j + 1;

            let product = num1[i] * num2[j] + (result[index2] || 0);
            result[index2] = product % 10;
            result[index1] = Math.floor(product / 10) + (result[index1] || 0);
        }
    }
    return result.join('').replace(/^0+/, '');
}
~~~

###

~~~js
function add(a) {
    return function (b) {
        return function (c) {
            return a + b + c;
        }
    }
}
~~~

### 15、实现add(1)(2)(3)

函数柯里化：柯里化是把接受 多个参数的函数 转变为接受 一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术

~~~js
//粗暴版
function add(a) {
    return function (b) {
        return function (c) {
            return a + b + c;
        }
    }
}
--------------------
//柯里化
const curry = (fn, ...args) => {
    // 函数的参数个数可以直接通过函数数的.length属性来访问
    if (fn.length === args.length) {
        // 传入的参数大于等于原始函数fn的参数个数，则直接执行该函数
        return fn.call(fn, ...args);
    }
    // 传入的参数小于原始函数fn的参数个数时
    // 则继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数） 的函数
    return (...rest) => curry(fn, ...args, ...rest);
};
const add = (x, y, z) => x + y + z;
const curryAdd = curry(add);

console.log(curryAdd(1, 2, 3))
console.log(curryAdd(1, 2)(3))
console.log(curryAdd(1)(2, 3))
console.log(curryAdd(1)(2)(3))
~~~

### 16、实现类数组转化为数组

~~~js
//通过call调用数组的slice方法来实现转换
Array.prototype.slice.call(arrayLike);
//通过call调用数组的splice方法来实现转换
Array.prototype.splice.call(arrayLike);
//通过apply调用数组的concat方法来实现转换
Array.prototype.concat.apply([],arrayLike)
//通过Array.form方法来实现转换
Array.from(arrayLike);
~~~

### 17、使用reduce求和

~~~js
//普通数组
let arr = [1, 1, 1, 1, 1];
arr.reduce((prev, cur) => { return prev + cur }, 0);
----------------------------------------------------------
//多维数组
let arr = [1, 2, [[3, 4], 5]];
arr.flat(Infinity).reduce((prev, cur) => { return prev + cur }, 0);
----------------------------------------------------------
//对象数组
let arr = [{ a: 1, b: 2 }, { a: 2, b: 2, c: 2 }]
arr.reduce((prev, cur) => {
    return prev + cur["a"];
}, 0)
~~~

### 18、将js对象转换为树型结构

~~~js
function jsonToTree(data) {
    let res = [];
    if (!Array.isArray(data)) {
        return res;
    }
    let map = {};
    data.forEach(item => {
        map[item.id] = item;
    });
    data.forEach(item => {
        let parent = map[item.pid];
        if (parent) {
            (parent.children || (parent.children = [])).push(item);
        } else {
            res.push(item);
        }
    });
    return res
}
~~~

### 19、使用ES5和ES6求函数参数的和

~~~js
//ES5,arguments 不是数组，所以不能直接使用数组的原生 API 如 forEach
function sum() {
    let sum = 0
    Array.prototype.forEach.call(arguments, function (item) {
        sum += item * 1
    })
    return sum
}
----------------------------------------------------------
//ES6
function sum(...nums) {
    let sum = 0
    nums.forEach(function (item) {
        sum += item * 1
    })
    return sum
}
~~~

### 20、解析URL Params为对象

~~~js
function parseParam(url) {
    // 将？后面的字符串取出来
    const paramsStr = /.+\?(.+)$/.exec(url)[1];
    // 将字符串以&分割后存到数组中
    const paramsArr = paramsStr.split('&');
    let paramsObj = {};
    paramsArr.forEach(param => {
        if (/=/.test(param)) {
            let [key, val] = param.split('=')
            val = decodeURIComponent(val);  //解码
            val = /^\d+$/.test(val) ? parseFloat(val) : val;
            if (paramsObj.hasOwnProperty(key)) {
                paramsObj[key] = [].concat(paramsObj[key], val);
            } else {
                paramsObj[key] = val;
            }
        } else {
            paramsObj[param] = true;
        }
    })
    return paramsObj;
}
~~~

### 21、在有序二维数组中查找目标值

~~~js
function findNum(matrix, target) {
    if (matrix == null || matrix.length == 0) {
        return false
    }
    let row = 0
    let column = matrix[0].length - 1
    while (row < matrix.length && column >= 0) {
        if (matrix[row][column] == target) {
            return true
        } else if (matrix[row][column] > target) {
            column--
        } else {
            row++
        }
    }
    return false
}
~~~

### 22、二维数组斜向打印

~~~js
function printMatrix(arr) {
    let m = arr.length, n = arr[0].length;
    let res = [];

    for (let k = 0; k < n; k++) {
        for (let i = 0, j = k; i < m && j >= 0; i++, j--) {
            res.push(arr[i][j]);
        }
    }

    for (let k = 1; k < m; k++) {
        for (let i = k, j = n - 1; i < m && j >= 0; i++, j--) {
            res.push(arr[i][j]);
        }
    }
    return res;
}
~~~

### 23、找出Element元素的全部Input子元素

~~~js
//普通
div.getElementsByTagName("INPUT")
----------------------------------------------------------
//深度递归
function findAllInput(element) {
    const rec = function (element, arr) {
        if (element.nodeName.toUpperCase() === "INPUT") {
            arr.push(element)
        }
        let children = element.childNodes
        children.orEach(element => {
            rec(element, arr)
        });
        return arr
    }
    return rec(element, [])
}
~~~

### 24、手机号码中间四位变成*

~~~js
// 使用数组的split、splice、join方法
let tel = 18877776666;
tel = "" + tel;
let array = tel.split("");
array.splice(3, 4, "****");
let newTel = array.join("");
---------------------------------------------
//正则
let tel = 18877776666;
tel = "" + tel;
let reg = /(\d{3})\d{4}(\d{4})/;
let newTel = tel.replace(reg, "$1****$2");
~~~




## 三、场景应用

### 1、循环打印红黄绿灯

~~~js
//红黄绿:使用异步编程方案;循环打印:一轮打印完了以后递归重复这一过程使用异步编程方案
const taskRunner = (light, timeout) => {
    return new Promise((resolve) => {
        setTimeout(() => resolve(console.log(light)), timeout);
    })
}
const task = async () => {
    await taskRunner('红', 1000)
    await taskRunner('绿', 3000)
    await taskRunner('黄', 2000)
    task()
}

task()
~~~

### 2、每隔一秒打印1,2,3,4

~~~js
//使用定时器
for (let i = 0; i < 4; i++) {
    setTimeout(function () {
        console.log(i + 1)
    }, i * 1000)
}
~~~

### 3、小孩报数问题

有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3数到3的小孩儿退出这个圈，然后下一个小孩重新报数1、2、3，问最后剩下的那个小孩儿的编号是多少?

~~~js
function childNum(num, count) {
    // 用数组记录
    let allplayer = [];
    for (let i = 0; i < num; i++) {
        allplayer[i] = i + 1;
    }

    let exitCount = 0;  //离开人数
    let counter = 0;    //记录报数
    let curIndex = 0;   //当前下标

    while (exitCount < num - 1) {
        if (allplayer[curIndex] !== 0) counter++;
        if (counter == count) {
            allplayer[curIndex] = 0;
            counter = 0;
            exitCount++;
        }
        curIndex++;
        if (curIndex == num) curIndex = 0;
    }
    for (let i = 0; i < num; i++) {
        if (allplayer[i] !== 0) {
            return allplayer[i]
        }
    }
}
console.log(childNum(30, 3))
~~~

### 4、Promise实现图片的异步加载

~~~js
let imageAsync = (url) => {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.src = url;
        img.onload = (image) => {
            console.log('图片请求成功')
            resolve(image)
        }
        img.onerror = (err) => {
            console.log('图片请求失败')
            reject(err)
        }
    })
}
imageAsync("url").then(() => {
    console.log("加载成功")
}).catch((error) => {
    console.log("加载失败")
})
~~~

###  5、实现发布-订阅者模式

~~~js
class EventCenter {
    // 1.定义事件容器
    constructor() {
        this.handlers = {}
    }
    // 2.添加事件方法（事件名，事件方法）
    addEventListener(type, handler) {
        // 创建新数组容器
        if (!this.handlers[type]) {
            this.handlers[type] = []
        }
        // 存入事件
        this.handlers[type].push(handler)
    }
    // 3.触发事件（事件名，事件参数）
    dispatchEvent(type, params) {
        // 没有注册该事件则抛出错误
        if (!this.handlers[type]) {
            return new Error('该事件未注册')
        }
        // 触发事件
        this.handlers[type].forEach(handler => {
            handler(...params)
        });
    }
    // 4.事件移除      （事件名，事件方法）
    removeEventListener(type, handler) {
        if (!this.handlers[type]) {
            return new Error('事件无效')
        }
        if (!handler) {
            // 移除事件
            delete this.handlers[type]
        } else {
            const index = this.handlers[type].findIndex(el => el === handler)
            if (index === -1) {
                return new Error('无法绑定该事件')
            }
        }
        // 移除事件
        this.handlers[type].splice(index, 1)
        if (this.handlers[type].length === 0) {
            delete this.handlers[type]
        }
    }
}
~~~

### 6、查找文章中出现频率最高的单词

~~~js
function counts(article) {
    article = article.trim().toUpperCase();
    var array = article.match(/[A-z]+/g);
    article = " " + array.join("  ") + " ";
    var max = 0, word, num = 0, maxword = "";
    for (var i = 0; i < array.length; i++) {
        word = new RegExp(" " + array[i] + " ", 'g');
        num = article.match(word).length;
        if (num > max) {
            max = num;
            maxword = array[i];
        }
    }
    console.log(maxword + " " + max);
}
counts("I fall in love with I at the first sight!");
~~~

### 7、封装异步的fetch，使用async,await方式使用

~~~js
(async () => {
    class HttpRequestUtil {
        async get(url) {
            const res = await fetch(url)
            const data = await res.json()
            return data
        }
        async post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
        async put(url, data) {
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
        async delete(url, data) {
            const res = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
    }
    const httpRequestUtil = new HttpRequestUtil()
    const res = await httpRequestUtil.get('https://www.baidu.com/')
    console.log(res)
})();
~~~

### 8、实现prototype继承

原型链继承就是让新实例的原型等于父类的实例

~~~js
function FatherFunction(flag1) {
    this.flag1 = flag1;
}
function SonFunction(flag2) {
    this.flag2 = flag2;
}
var fatherInstance = new FatherFunction(true);
SonFunction.prototype = fatherInstance;
var sonInstance = new SonFunction(false);
console.log(sonInstance.flag1); //true
console.log(sonInstance.flag2); //false
~~~

### 9、实现双向数据绑定

~~~js
<body>
    <input type="text" id="input">
    <span id="span"></span>

    <script>
        let obj = {}
        let input = document.getElementById('input')
        let sapn = document.getElementById('span')
        Object.defineProperty(obj, 'text', {
            get() {
                console.log('获取数据了')
            },
            set(newVal) {
                console.log('获取数据了')
                input.value = newVal
                span.innerHTML = newVal
            }
        })
        input.addEventListener('keyup', function (e) {
            obj.text = e.target.value
        })
    </script>
</body>
~~~

### 10.实现简单路由

~~~js
<body>
    <ul>
        <li><a onclick="location.href='#/'">首页</a></li>
        <li><a href="#/product">产品</a></li>
        <li><a onclick="location.href='#/server'">服务</a></li>
    </ul>
    <div id="result"></div>

    <script type="text/javascript">
        function Router() {
            this.routers = {};
            this.curUrl = '';

            this.route = function (path, callback) {
                this.routers[path] = callback || function () { };
            };

            this.refresh = function () {
                console.log(location.hash);
                this.curUrl = location.hash.slice(1) || '/';
                this.routers[this.curUrl]();
            }
            this.init = function () {
                window.addEventListener('load', this.refresh.bind(this), false);
                window.addEventListener('hashchange', this.refresh.bind(this), false);
            }
        }

        var R = new Router();
        R.init();
        var res = document.getElementById('result');

        R.route('/', function () {
            res.style.background = 'blue';
            res.innerHTML = '这是首页';
        });
        R.route('/product', function () {
            res.style.background = 'orange';
            res.innerHTML = '这是产品页';
        });
        R.route('/server', function () {
            res.style.background = 'black';
            res.innerHTML = '这是服务页';
        });
    </script>
</body>
~~~


### 11、实现斐波拉契数列

~~~js
function fn(n) {
    if (n == 1 || n == 2) {
        return 1
    } else {
        return fn(n - 2) + fn(n - 1)
    }
}
--------------------------------------
function fn(n) {
    var num1 = 1, num2 = 1, sum;

    for (var i = 3; i <= n; i++) {
        sum = num1 + num2;   //用sum累加前两个数之和
        num1 = num2;
        num2 = sum;
    }

    if (n == 1 || n == 2) {
        return 1
    } else {
        return sum
    }
}
~~~

### 12、字符串中无重复字符的最长子串

滑动窗口装没有重复的字符，用map维护字符的索引

~~~js
var lengthOfLongestSubstring = function (s) {
    let map = new Map()
    let i = -1
    let res = 0
    let len = s.length
    for (let j = 0; j < len; j++) {
        if (map.has(s[j])) {
            i = Math.max(i, map.get(s[j]))
        }
        res = Math.max(res, j - i)
        map.set(s[j], j)
    }
    return res
}
~~~

### 13、使用setTimeout实现setInterval

setInterval不是每隔一段时间立即执行，而是每隔一段时间将事件加入事件队列中，只有当前执行栈为空时，才能从事件队列中取出事件执行，积累多个事件的话就不能实现间隔执行的效果

~~~js
function mySetInterval(fn, timeout) {
    var timer = { flag: true }
    // 设置递归函数，模拟定时器执行
    function interval() {
        if (time.flag) {
            fn()
            setTimeout(interval, timeout)
        }
    }
}
// 启动定时器
setTimeout(interval, timeout)
// 返回控制器
return timer
~~~

### 14、实现jsonp

JSONP(JSON with Padding)是[JSON](https://baike.baidu.com/item/JSON?fromModule=lemma_inlink)的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题，利用的就是script的src标签没有跨域限制来实现的

~~~js
function addScript(src) {
    const script = document.createElement('script')
    script.src = src
    script.type = "text/javascript"
    document.body.appendChild(script)
}
addScript("http://xxx.xxx.com/xxx.js?callback=handleRes")
function handleRes(res) {
    console.log(res)
}
handleRes({ a: 1, b: 2 })
~~~

### 15、判断对象之间是否存在循环引用

循环引用是指对象中的属性指向对象本身，如果属性内部的深层属性指向对象本身，也属于循环引用

~~~js
const isCycleObject = (obj, parent) => {
    const parentArr = parent || [obj];
    for (let i in obj) {
        if (typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) => {
                if (pObj === obj[i]) {
                    flag = true;
                }
            })
            if (flag) return true;
            flag = isCycleObject(obj[i], [...parentArr, obj[i]]);
            if (flag) return true;
        }
    }
    return false;
}

let a = {}
a.b = {}
a.b.c = a
console.log(isCycleObject(a))
~~~





