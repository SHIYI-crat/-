# 手写代码

## 一、js基础
### 1、手写Object.create


~~~js
function create(obj){
    function F(){}
    F.prototype = obj
    return new F()
}
~~~



### 2、

~~~js

~~~



 ###

~~~js

~~~





## 二、数据处理

### 1、

~~~js

~~~



 ###

~~~js

~~~






## 三、场景应用

### 1、循环打印红黄绿灯

~~~js
//红黄绿:使用异步编程方案;循环打印:一轮打印完了以后递归重复这一过程使用异步编程方案
const taskRunner = (light, timeout) => {
    return new Promise((resolve) => {
        setTimeout(() => resolve(console.log(light)), timeout);
    })
}
const task = async () => {
    await taskRunner('红', 1000)
    await taskRunner('绿', 3000)
    await taskRunner('黄', 2000)
    task()
}

task()
~~~

### 2、每隔一秒打印1,2,3,4

~~~js
//使用定时器
for (let i = 0; i < 4; i++) {
    setTimeout(function () {
        console.log(i + 1)
    }, i * 1000)
}
~~~

### 3、小孩报数问题

有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3数到3的小孩儿退出这个圈，然后下一个小孩重新报数1、2、3，问最后剩下的那个小孩儿的编号是多少?

~~~js
function childNum(num, count) {
    // 用数组记录
    let allplayer = [];
    for (let i = 0; i < num; i++) {
        allplayer[i] = i + 1;
    }

    let exitCount = 0;  //离开人数
    let counter = 0;    //记录报数
    let curIndex = 0;   //当前下标

    while (exitCount < num - 1) {
        if (allplayer[curIndex] !== 0) counter++;
        if (counter == count) {
            allplayer[curIndex] = 0;
            counter = 0;
            exitCount++;
        }
        curIndex++;
        if (curIndex == num) curIndex = 0;
    }
    for (let i = 0; i < num; i++) {
        if (allplayer[i] !== 0) {
            return allplayer[i]
        }
    }
}
console.log(childNum(30, 3))
~~~

### 4、Promise实现图片的异步加载

~~~js
let imageAsync = (url) => {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.src = url;
        img.onload = (image) => {
            console.log('图片请求成功')
            resolve(image)
        }
        img.onerror = (err) => {
            console.log('图片请求失败')
            reject(err)
        }
    })
}
imageAsync("url").then(() => {
    console.log("加载成功")
}).catch((error) => {
    console.log("加载失败")
})
~~~

###  5、实现发布-订阅者模式

~~~js
class EventCenter {
    // 1.定义事件容器
    constructor() {
        this.handlers = {}
    }
    // 2.添加事件方法（事件名，事件方法）
    addEventListener(type, handler) {
        // 创建新数组容器
        if (!this.handlers[type]) {
            this.handlers[type] = []
        }
        // 存入事件
        this.handlers[type].push(handler)
    }
    // 3.触发事件（事件名，事件参数）
    dispatchEvent(type, params) {
        // 没有注册该事件则抛出错误
        if (!this.handlers[type]) {
            return new Error('该事件未注册')
        }
        // 触发事件
        this.handlers[type].forEach(handler => {
            handler(...params)
        });
    }
    // 4.事件移除      （事件名，事件方法）
    removeEventListener(type, handler) {
        if (!this.handlers[type]) {
            return new Error('事件无效')
        }
        if (!handler) {
            // 移除事件
            delete this.handlers[type]
        } else {
            const index = this.handlers[type].findIndex(el => el === handler)
            if (index === -1) {
                return new Error('无法绑定该事件')
            }
        }
        // 移除事件
        this.handlers[type].splice(index, 1)
        if (this.handlers[type].length === 0) {
            delete this.handlers[type]
        }
    }
}
~~~

### 6、查找文章中出现频率最高的单词

~~~js
function counts(article) {
    article = article.trim().toUpperCase();
    var array = article.match(/[A-z]+/g);
    article = " " + array.join("  ") + " ";
    var max = 0, word, num = 0, maxword = "";
    for (var i = 0; i < array.length; i++) {
        word = new RegExp(" " + array[i] + " ", 'g');
        num = article.match(word).length;
        if (num > max) {
            max = num;
            maxword = array[i];
        }
    }
    console.log(maxword + " " + max);
}
counts("I fall in love with I at the first sight!");
~~~

### 7、封装异步的fetch，使用async,await方式使用

~~~js
(async () => {
    class HttpRequestUtil {
        async get(url) {
            const res = await fetch(url)
            const data = await res.json()
            return data
        }
        async post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
        async put(url, data) {
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
        async delete(url, data) {
            const res = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            const result = await res.json()
            return result
        }
    }
    const httpRequestUtil = new HttpRequestUtil()
    const res = await httpRequestUtil.get('https://www.baidu.com/')
    console.log(res)
})();
~~~

### 8、实现prototype继承

原型链继承就是让新实例的原型等于父类的实例

~~~js
function FatherFunction(flag1) {
    this.flag1 = flag1;
}
function SonFunction(flag2) {
    this.flag2 = flag2;
}
var fatherInstance = new FatherFunction(true);
SonFunction.prototype = fatherInstance;
var sonInstance = new SonFunction(false);
console.log(sonInstance.flag1); //true
console.log(sonInstance.flag2); //false
~~~

### 9、实现双向数据绑定

~~~js
<body>
    <input type="text" id="input">
    <span id="span"></span>

    <script>
        let obj = {}
        let input = document.getElementById('input')
        let sapn = document.getElementById('span')
        Object.defineProperty(obj, 'text', {
            get() {
                console.log('获取数据了')
            },
            set(newVal) {
                console.log('获取数据了')
                input.value = newVal
                span.innerHTML = newVal
            }
        })
        input.addEventListener('keyup', function (e) {
            obj.text = e.target.value
        })
    </script>
</body>
~~~

### 10.实现简单路由

~~~js
<body>
    <ul>
        <li><a onclick="location.href='#/'">首页</a></li>
        <li><a href="#/product">产品</a></li>
        <li><a onclick="location.href='#/server'">服务</a></li>
    </ul>
    <div id="result"></div>

    <script type="text/javascript">
        function Router() {
            this.routers = {};
            this.curUrl = '';

            this.route = function (path, callback) {
                this.routers[path] = callback || function () { };
            };

            this.refresh = function () {
                console.log(location.hash);
                this.curUrl = location.hash.slice(1) || '/';
                this.routers[this.curUrl]();
            }
            this.init = function () {
                window.addEventListener('load', this.refresh.bind(this), false);
                window.addEventListener('hashchange', this.refresh.bind(this), false);
            }
        }

        var R = new Router();
        R.init();
        var res = document.getElementById('result');

        R.route('/', function () {
            res.style.background = 'blue';
            res.innerHTML = '这是首页';
        });
        R.route('/product', function () {
            res.style.background = 'orange';
            res.innerHTML = '这是产品页';
        });
        R.route('/server', function () {
            res.style.background = 'black';
            res.innerHTML = '这是服务页';
        });
    </script>
</body>
~~~





