# 爬楼梯

~~~js
const f = []
var climbStairs = function(n) {
    if(n === 1){
        return 1
    }
    if(n === 2){
        return 2
    }
    if(f[n] === undefined) 
        f[n] = climbStairs(n-1) + climbStairs(n-2)
    return f[n]
};

---------------------------------------------------------
var climbStairs = function(n) {
    const f = []
    f[1] = 1
    f[2] = 2
    for(let i = 3;i <= n;i++){
        f[i]  = f[i-2] + f[i-1]
    }
    return f[n]
};
~~~

# 合并有序数组

~~~js
const merge = function (nums1, m, nums2, n) {
            let i = m-1,j = n-1,k=m+n-1
            while(i>=0&&j>=0){
                if(nums1[i]>=nums2[j]){
                    nums1[k] = nums1[i]
                    i--
                    k--
                } else {
                    nums1[k] = nums2[j]
                    j--
                    k--
                }
            }

        while(j>=0){
            nums1[k] = nums2[j]
            k--
            j--
        }
}
--------------------------------------
const merge = function (nums1, m, nums2, n) {
    nums1.splice(m,nums1.length-m,...nums2);
    nums1.sort((a,b) => a - b)
}
~~~

# 删除链表倒数第n个元素

~~~js
var removeNthFromEnd = function(head, n) {
    let p = head
    
    for(let i = 1;i < n;i++)
        p = p.next

    let dump = cur = {val:undefined,next:head}
    while(p.next){
        cur = cur.next
        p = p.next
    }

    cur.next = cur.next.next

    return dump.next
};
~~~

# 二叉树最近公共祖先

~~~js
var lowestCommonAncestor = function(root, p, q) {
    if(!root || root === p || root === q) return root;
    let left = lowestCommonAncestor(root.left, p ,q);
    let right = lowestCommonAncestor(root.right, p, q);
    if(!left) return right;
    if(!right) return left;
    return root;
};
~~~

# 反转链表

~~~js
var reverseList = function(head) {
    let pre = null;
    let cur = head;
    while(cur !== null){
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
};
~~~

# 有效括号对

~~~js
var reverseList = function(head) {
    let pre = null;
    let cur = head;
    while(cur !== null){
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
};
~~~

# 验证二叉搜索树

~~~js
var isValidBST = function(root) {
    function dfs(root,minValue,maxValue){
        if(!root){
            return true
        }
        if(root.val <= minValue || root.val >= maxValue)
            return false
        return dfs(root.left,minValue,root.val)&&dfs(root.right,root.val,maxValue)
    }
    return dfs(root,-Infinity,Infinity)
};
~~~

# 二分查找

~~~js
var search = function(nums, target) {
    let low = 0,high =nums.length - 1;
    while(low<=high){
        let mid = Math.floor((high - low)/2) + low;
        let num = nums[mid];
        if(num === target){
            return mid;
        }else if(num > target){
            high = mid - 1;
        }else{
            low = low + 1;
        }
    }
    return - 1;
};
~~~

# 两数之和

~~~js
var twoSum = function(nums, target) {
    const map = new Map()
    let len = nums.length
    for(let i = 0;i<len;i++){
        const value = target - nums[i];
        if(map.has(value)){
            return [map.get(value),i]
        }else{
            map.set(nums[i],i)
        }
    }

};
~~~

# 层序遍历

~~~js
var levelOrder = function(root) {
    if(!root){
        return [];
    }
    const queue = [root];
    const res = [];
    let level = 0;
    while(queue.length){
        res[level] = [];
        let levelNum = queue.length;
        while(levelNum--){
            const cur =  queue.shift();
            res[level].push(cur.val);
            if(cur.left!==null){
                queue.push(cur.left)
            }
            if(cur.right!==null){
                queue.push(cur.right)
            }
        }
        level++;
    }
    return res;
};
~~~

# 删除链表重复元素

~~~js
var deleteDuplicates = function(head) {
    let cur = head
    while(cur != null && cur.next != null){
        if(cur.val === cur.next.val){
                cur.next = cur.next.next
        }else{
            cur = cur.next
        }
    }
    return head
};
~~~

# 数组中数字出现次数

~~~js
var singleNumbers = function(nums) {
    let numsSort = nums.sort((a,b)=>{ return a-b }),result = []
    for(let i=0;i<numsSort.length;i++){
        if(numsSort[i]===numsSort[i+1]){
            i++
        }else{
            result.push(numsSort[i])
            if(result.length===2) break
        }
    }
    return result
};
~~~

# 最长不含重复字符的子字符串

~~~js
var lengthOfLongestSubstring = function(s) {
    let arr = [];
    let max = 0;
    for(let item of s){
        if(arr.includes(item)){
            let index = arr.indexOf(item);
            arr.splice(0, index + 1);
        }
        arr.push(item);
        max = max > arr.length ? max : arr.length;
    }
    return max;
};
~~~

# 最长递增子序列

~~~js
const lengthOfLIS = function(nums) {
    // 因为每个元素都能自己组成一个长度为1的子序列，所以dp数组所有元素的初始值设置为1
    const dp = new Array(nums.length).fill(1)
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            // 找出第i个元素之前的序列中，有多少个元素比其更小
            if (nums[j] < nums[i]) {
                // 相当于找到了一个j，则dp[i]就加1，一直从0找到i-1
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return Math.max(...dp)
}
~~~

# 中序遍历二叉树

~~~js
var inorderTraversal = function(root) {
    const res = []
    const stack = []
    let cur = root
    while(cur||stack.length){
        while(cur){
            stack.push(cur)
            cur=cur.left
        }
        cur = stack.pop()
        res.push(cur.val)
        cur = cur.right
    }
    return res
};
~~~

