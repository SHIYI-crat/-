# 《前端算法与数据结构面试》学习笔记



​                       **----面试是个技术活，不是体力活；理解面试本身，比理解算法更重要**

 

## 1、数组 -- 第一个数据结构

* 创建

~~~JavaScript
const arr = [1,2,3,4]

const arr = new Array()//推荐构造函数创建数组的方法

const arr = (new Array(7)).fill(1)//长度为7，初始化为1
~~~



* 访问与遍历

~~~javascript
arr[0] // 访问索引下标为0的元素


// 遍历
//for循环 -- 性能上看，for 循环遍历起来是最快的
for(let i=0;i<arr.length;i++) {
    // 输出数组的元素值，输出当前索引
    console.log(arr[i], i)
}
//forEach方法
arr.forEach((item, index)=> {
    // 输出数组的元素值，输出当前索引
    console.log(item, index)
})
//map方法 -- map 做的事情不仅仅是遍历，而是在遍历的基础上“再加工”
const newArr = arr.map((item, index)=> {
    // 输出数组的元素值，输出当前索引
    console.log(item, index)
    // 在当前元素值的基础上加1
    return item+1
})
~~~



* 二维数组(矩阵)创建

~~~JavaScript
const arr = [
  [1,2,3,4,5],
  [1,2,3,4,5],
  [1,2,3,4,5],
  [1,2,3,4,5],
  [1,2,3,4,5]
]

for(let i=0;i<arr.length;i++) {
    // 将数组的每一个坑位初始化为数组
    arr[i] = []
}
~~~



* 二维数组(矩阵)访问

~~~JavaScript
// 缓存外部数组的长度
const outerLen = arr.length
for(let i=0;i<outerLen;i++) {
    // 缓存内部数组的长度
    const innerLen = arr[i].length
    for(let j=0;j<innerLen;j++) {
        // 输出数组的值，输出数组的索引
        console.log(arr[i][j],i,j)
    }
}
~~~



## 2、栈和队列 -- 特别的数组

* 数组增加元素

~~~javascript
//unshift 方法-添加元素到数组的头部
const arr = [1,2]
arr.unshift(0)//[0,1,2]

//push 方法-添加元素到数组的尾部
const arr = [1,2]
arr.push(3)//[1,2,3]

//splice 方法-添加元素到数组的任何位置
const arr = [1,3]
arr.splice(1,0,2)//[1,2,3]
//起始的索引值 从起始索引开始需要删除的元素个数 新增的元素值
arr.splice(1,1)
//起始的索引值 从起始索引开始需要删除的元素个数
~~~



* 数组删除元素

~~~JavaScript
//shift 方法-删除数组头部的元素
const arr = [1,2,3]
arr.shift()//[2,3]

//pop 方法-删除数组尾部的元素
const arr = [1,2,3]
arr.pop()//[1,2]

//splice 方法-删除数组任意位置的元素
略
~~~



* 栈 -- 只用 pop 和 push 完成增删的“数组”(LIFO)
  * 只允许从尾部添加元素
  * 只允许从尾部取出元素

~~~JavaScript
// 初始状态，栈空
const stack = []  
// 入栈过程
stack.push('东北大板')
stack.push('可爱多')
stack.push('巧乐兹')
stack.push('冰工厂')
stack.push('光明奶砖')

// 出栈过程，栈不为空时才执行
while(stack.length) {
    // 单纯访问栈顶元素（不出栈）
    const top = stack[stack.length-1]
    console.log('现在取出的冰淇淋是', top)  
    // 将栈顶元素出栈
    stack.pop()
}

// 栈空
stack // []
~~~



* 队列 -- 只用 push 和 shift 完成增删的“数组”(FIFO)
  * 只允许从尾部添加元素
  * 只允许从头部移除元素

~~~javascript
const queue = []  
queue.push('小册一姐')
queue.push('小册二姐')
queue.push('小册三姐')  
  
while(queue.length) {
    // 单纯访问队头元素（不出队）
    const top = queue[0]
    console.log(top,'取餐')
    // 将队头元素出队
    queue.shift()
}

// 队空
queue // []
~~~



## 3、链表 -- “离散”的数组

* 链表结点的创建

~~~javascript
function ListNode(val) {
    this.val = val;
    this.next = null;
}

const node = new ListNode(1)  
node.next = new ListNode(2)
~~~



* 链表元素的添加 -- 任意两结点间插入一个新结点

~~~JavaScript
// 如果目标结点本来不存在，那么记得手动创建
const node3 = new ListNode(3)     
// 把node3的 next 指针指向 node2（即 node1.next）
node3.next = node1.next
// 把node1的 next 指针指向 node3
node1.next = node3
~~~



* 链表元素的删除

~~~JavaScript
node1.next = node3.next 
//js垃圾回收器自动回收

const target = node1.next  
node1.next = target.next
//同上
~~~



* 链表与数组的辨析
  * 在一个数组中只定义了一种类型的元素，对应的确实是连续内存
  * 定义了不同类型的元素，对应的就是一段非连续的内存，底层使用**哈希映射分配内存空间**，是由**对象链表**来实现的
  * **js数组未必是真正的数组**
  * 相对于数组来说，链表有一个明显的优点，就是**添加和删除元素都不需要挪动多余的元素**
  * **链表**的**插入/删除效率较高**，而**访问效率较低**；**数组**的**访问效率较高**，而**插入效率较低**



## 4、树与二叉树

* 树结构
  * 树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
  * 结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
  * “度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。
  * “叶子结点”：叶子结点就是度为0的结点。



* 二叉树结构
  * 它可以没有根结点，作为一棵空树存在
  * 如果它不是空树，那么**必须由根结点、左子树和右子树组成，且左右子树都是二叉树**



* 二叉树的创建

~~~JavaScript
// 二叉树结点的构造函数
function TreeNode(val) {
    this.val = val;
    this.left = this.right = null;
}

const node  = new TreeNode(1)
~~~



* **二叉树的遍历**

  * 递归遍历（先、中、后序遍历）

    * **根结点 -> 左子树 -> 右子树（先序）**

    ~~~JavaScript
    // 所有遍历函数的入参都是树的根结点对象
    function preorder(root) {
        // 递归边界，root 为空
        if(!root) {
            return 
        }
         
        // 输出当前遍历的结点值
        console.log('当前遍历的结点值是：', root.val)  
        // 递归遍历左子树 
        preorder(root.left)  
        // 递归遍历右子树  
        preorder(root.right)
    }
    ~~~

    * **左子树 -> 根结点 -> 右子树（中序）**

    ~~~javascript
    // 所有遍历函数的入参都是树的根结点对象
    function inorder(root) {
        // 递归边界，root 为空
        if(!root) {
            return 
        }
         
        // 递归遍历左子树 
        inorder(root.left)  
        // 输出当前遍历的结点值
        console.log('当前遍历的结点值是：', root.val)  
        // 递归遍历右子树  
        inorder(root.right)
    }
    ~~~

    * **左子树 -> 右子树 -> 根结点（后序）**

    ~~~javascript
    function postorder(root) {
        // 递归边界，root 为空
        if(!root) {
            return 
        }
         
        // 递归遍历左子树 
        postorder(root.left)  
        // 递归遍历右子树  
        postorder(root.right)
        // 输出当前遍历的结点值
        console.log('当前遍历的结点值是：', root.val)  
    }
    ~~~

  * 迭代遍历（层次遍历）



## 5、算法的衡量 -- 时间复杂度和空间复杂度

* 时间复杂度

  * 在所有的 `for` 循环里，判断语句都会比递增语句多执行一次
  * 计算T(n) -> 推导O(n)
  * 常见的时间复杂度

  ~~~javascript
  //常数<  对数<  线性<  线性对数<  二次<  三次<  指数
  O(1)< O(logn)< O(n)< O(nlogn)< O(n^2)< O(n^3)< O(2^n) 
  ~~~



* 空间复杂度
  * 时间复杂度相似，它是内存增长的**趋势**



## 6、数组的应用

### Map的妙用 -- 两数求和问题

* 淳朴解：两层循环，时间复杂度高；**几乎所有的求和问题，都可以转化为求差问题**

~~~JavaScript
//对象字面量解法
const twoSum = function(nums, target) {
    // 这里用对象来模拟 map 的能力
    const diffs = {}
    // 缓存数组长度
    const len = nums.length
    // 遍历数组
    for(let i=0;i<len;i++) {
        // 判断当前值对应的 target 差值是否存在（是否已遍历过）
        if(diffs[target-nums[i]]!==undefined) {
            // 若有对应差值，那么答案get！
            return [diffs[target - nums[i]], i]
        }
        // 若没有对应差值，则记录当前值
        diffs[nums[i]]=i
    }
};

//Map解法
const twoSum = function (nums, target) {

    const map = new Map();

    for (let i = 0; i < nums.length; i++) {

        const value = target - nums[i];

        if (map.has(value)) {
            return [map.get(value), i]
        } else {
            map.set(nums[i], i)
        }
    }
}
~~~



### 强大的双指针法 -- 合并两个有序数组

~~~javascript
//双指针解法
const merge = function(nums1, m, nums2, n) {
    // 初始化两个指针的指向，初始化 nums1 尾部索引k
    let i = m - 1, j = n - 1, k = m + n - 1
    // 当两个数组都没遍历完时，指针同步移动
    while(i >= 0 && j >= 0) {
        // 取较大的值，从末尾往前填补
        if(nums1[i] >= nums2[j]) {
            nums1[k] = nums1[i] 
            i-- 
            k--
        } else {
            nums1[k] = nums2[j] 
            j-- 
            k--
        }
    }
    
    // nums2 留下的情况，特殊处理一下 
    while(j>=0) {
        nums1[k] = nums2[j]  
        k-- 
        j--
    }
};

//扩展运算符先合并再排序
const merge = function (num1, m, num2, n) {
    nums1.splice(m, nums1.length - m, ...nums2);
    nums1.sort((a, b) => a - b);
}
~~~



### 双指针加强 -- 三数求和问题

* “有序”和“数组” ==》“对撞指针”

~~~JavaScript
const threeSum = function(nums) {
    // 用于存放结果数组
    let res = [] 
    // 给 nums 排序
    nums = nums.sort((a,b)=>{
        return a-b
    })
    // 缓存数组长度
    const len = nums.length
    // 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数
    for(let i=0;i<len-2;i++) {
        // 左指针 j
        let j=i+1 
        // 右指针k
        let k=len-1   
        // 如果遇到重复的数字，则跳过
        if(i>0&&nums[i]===nums[i-1]) {
            continue
        }
        while(j<k) {
            // 三数之和小于0，左指针前进
            if(nums[i]+nums[j]+nums[k]<0){
                j++
               // 处理左指针元素重复的情况
               while(j<k&&nums[j]===nums[j-1]) {
                    j++
                }
            } else if(nums[i]+nums[j]+nums[k]>0){
                // 三数之和大于0，右指针后退
                k--
               
               // 处理右指针元素重复的情况
               while(j<k&&nums[k]===nums[k+1]) {
                    k--
                }
            } else {
                // 得到目标数字组合，推入结果数组
                res.push([nums[i],nums[j],nums[k]])
                
                // 左右指针一起前进
                j++  
                k--
               
                // 若左指针元素重复，跳过
                while(j<k&&nums[j]===nums[j-1]) {
                    j++
                }  
               
               // 若右指针元素重复，跳过
               while(j<k&&nums[k]===nums[k+1]) {
                    k--
                }
            }
        }
    }
    
    // 返回结果数组
    return res
};
~~~



## 7、字符串的应用



## 8、链表的应用



## 9、快慢指针与多指针



## 10、环型链表





